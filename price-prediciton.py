# -*- coding: utf-8 -*-
"""Kaggle_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MAJxjPYqkfXjuJm6kHpYw39xKhFshpuN
"""

import torch
import torch.nn as nn
import torch.optim as optim
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
import numpy as np

# 讀取CSV文件
train_data = pd.read_csv('train-v3.csv')
valid_data = pd.read_csv('valid-v3.csv')
test_data = pd.read_csv('test-v3.csv')

# 提取特徵
X_train = train_data.drop('id', axis=1) # 把id那列從X_train中移除
X_train = X_train.drop(['price', 'sale_yr', 'sale_month', 'sale_day', 'sqft_lot', 'floors', 'waterfront', 'view', 'condition', 'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode', 'lat', 'long', 'sqft_lot15'], axis=1) # X_train只包含train-v3.csv中的19項特徵
price = train_data['price']
id = test_data['id']

X_val = valid_data.drop('id', axis=1)
X_val = X_val.drop(['price', 'sale_yr', 'sale_month', 'sale_day', 'sqft_lot', 'floors', 'waterfront', 'view', 'condition', 'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode', 'lat', 'long', 'sqft_lot15'], axis=1) #X_val是包含valid-v3.csv中的19項特徵
val_price = valid_data['price']

y_train = price #y_train是train-v3.csv中的價錢
y_train = torch.tensor(y_train, dtype=torch.float32) #轉換成適合的type
y_val = val_price #y_val是valid-v3.csv中的價錢

test_data = test_data.drop(['id', 'sale_yr', 'sale_month', 'sale_day', 'sqft_lot', 'floors', 'waterfront', 'view', 'condition', 'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode', 'lat', 'long', 'sqft_lot15'], axis=1) #把test_data中的id那列移除

# 數據標準化：
# 1. 使尺度保持一致性：把極端的數值稍微拉回來，訓練時的收斂速度才較快
# 2. 避免梯度爆炸或消失
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_val = scaler.fit_transform(X_val)
test_data = scaler.fit_transform(test_data)

class Net(nn.Module):
    def __init__(self, input_size):
        super(Net, self).__init__()
        self.fc1 = nn.Linear(input_size, 128)
        self.fc2 = nn.Linear(128, 64)
        self.fc3 = nn.Linear(64, 32)
        self.fc4 = nn.Linear(32, 1)

    def forward(self, x):
        x = torch.relu(self.fc1(x))
        x = torch.relu(self.fc2(x))
        x = torch.relu(self.fc3(x))
        x = self.fc4(x)
        return x

# 創建模型
input_dim = X_train.shape[1]
model = Net(input_dim)

criterion = nn.L1Loss()  # 使用L1Loss，即MAE
optimizer = optim.Adam(model.parameters(), lr=0.003) #利用Adam優化，學習率為0.003

num_epochs = 500 #迭代500次
batch_size = 32

losses = []

for epoch in range(num_epochs):
    for i in range(0, len(X_train), batch_size):
        inputs = torch.tensor(X_train[i:i+batch_size], dtype=torch.float32)
        targets = torch.tensor(y_train[i:i+batch_size], dtype=torch.float32)

        # 前向傳播
        outputs = model(inputs)

        # 計算loss
        loss = criterion(outputs, targets)

        # 反向傳播和優化
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

    # 印出每個epoch的損失
    print(f'Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item()}')
    losses.append(loss.item())

with torch.no_grad():
    val_inputs = torch.tensor(X_val, dtype=torch.float32)
    val_outputs = model(val_inputs)
    val_mae = criterion(val_outputs, torch.tensor(y_val.values, dtype=torch.float32))
    print(f'Validation MAE: {val_mae.item()}') # 印出最終的MAE

with torch.no_grad():
    test_inputs = torch.tensor(test_data, dtype=torch.float32)  # 將test-v3.csv轉換成適合的型別
    test_predictions = model(test_inputs) #將test-v3.csv放進model中

predicted_prices = test_predictions.numpy() # 將預測結果轉為 NumPy

predicted_prices = predicted_prices.flatten() # 將維度攤平

# 創建一個包含預測價格的 DataFrame
df = pd.DataFrame({'id': id, 'price': predicted_prices})

# 將 DataFrame 保存到 CSV 文件
df.to_csv('submission.csv', index=False)

# 繪製损失曲线
plt.figure(figsize=(10, 5))
x_values = range(1, num_epochs + 1)
y_values = losses[:num_epochs]  # 只保留與時期數相對應的損失值
plt.plot(x_values, y_values, label='training loss')
plt.xlabel('epoch')
plt.ylabel('loss')
plt.title('training loss')
plt.legend()
plt.show()

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression

train_data = pd.read_csv('train-v3.csv')

# 提取欲進行比較的數據
sqft_living15 = train_data['sqft_living15']
price = train_data['price']

model = LinearRegression() # 用Linear Regression做
sqft_living15 = sqft_living15.values.reshape(-1, 1)  # 將數量轉換成二维數組
model.fit(sqft_living15, price)

predicted_price = model.predict(sqft_living15)

# 創建散點圖來顯示兩筆資料之間的相關性
plt.figure(figsize=(10, 6))  # 設置圖形的大小
plt.scatter(sqft_living15, price, alpha=0.5)  # 創建散點圖
plt.plot(sqft_living15, predicted_price, color='red', linewidth=2, label='Regression Line') # 用紅線畫出回歸線
plt.title('Price vs sqft_living15')  # 設置圖的標題
plt.xlabel('sqft_living15')  # 設置 x 軸標籤
plt.ylabel('Price')  # 設置 y 軸標籤
plt.grid(True)  # 添加網格線
plt.show()  # 顯示圖形
